<!DOCTYPE html>
<html>
<head>
    <meta charset='utf-8' />
    <title>Mapbox Storytelling</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <link rel="icon" type="image/x-icon" href="https://raw.githubusercontent.com/mapbox/assembly/publisher-staging/src/svgs/mapbox.svg">
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v2.11.0/mapbox-gl.css' rel='stylesheet' />
    <script src="https://unpkg.com/intersection-observer@0.12.0/intersection-observer.js"></script>
    <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
    <script src="https://unpkg.com/scrollama"></script>
    <style>
        body {
            margin:0;
            padding:0;
            font-family: sans-serif;
        }
        a, a:hover, a:visited {
            color: #0071bc;
        }
        #map {
            top:0;
            height: 100vh;
            width:100vw;
            position: fixed;
        }
        #mapInset {
            bottom:50px;
            right:30px;
            height: 180px;
            width:250px;
            max-width:100%;
            position: fixed;
            z-index: 1;
            opacity: 1;
            transition: opacity 0.5s ease-in-out;
            pointer-events: none;
        }
        #mapInset .mapboxgl-ctrl-bottom-left{
            display: none;
        }
        @media (max-width: 500px) {
            #mapInset {
                display: none;
            }
        }
        #header {
            margin: auto;
            width: 100%;
            position: relative;
            z-index: 5;
        }
        #header h1, #header h2, #header p {
            margin: 0;
            padding: 2vh 2vw;
            text-align: center;
        }
        #footer {
            width: 100%;
            min-height: 5vh;
            padding-top: 2vh;
            padding-bottom: 2vh;
            text-align: center;
            line-height: 25px;
            font-size: 13px;
            position: relative;
            z-index: 5;
        }
        #features {
            padding-top: 10vh;
            padding-bottom: 10vh;
        }
        .hidden {
            visibility: hidden;
        }
        .centered {
            text-align: center;
            width: 50vw;
            margin: 0 auto;
        }
        .lefty {
            width: 33vw;
            margin-left: 5vw;
        }
        .lefty-large {
            width: 50vw;
            margin-left: 5vw;
        }
        .righty {
            width: 33vw;
            /* width: 50vw; */
            margin-left: 62vw;
        }
        .righty-large {
            width: 50vw;
            margin-left: 45vw;
        }
        .fully {
            width: 100%;
            margin: auto;
        }
        .light {
            color: #444;
            /* background-color: rgba(0,0,0,0); */
            background-color: #fafafa;
        }
        .dark {
            color: #fafafa;
            /* background-color: rgba(0,0,0,0); */
            background-color: #444;
        }
        .step {
            padding-bottom: 50vh;
            /* float:right; */
            /* display: flex; */
            /* margin-bottom: 10vh; */
            /* justify-content: center; */
            /* white-space: nowrap; */
            opacity: 0.25;
            /* display: flex; */
            /* overflow: hidden; */
        }
        .step.active {
            opacity: 0.9;
        }

        /* .step.imagebox {
            float:right;
        } */

        .step div {
            /* text-align: left; */
            padding:  25px 50px;
            line-height: 20px;
            font-size: 18px;
            text-align: center;
            /* white-space: nowrap; */
            /* margin: auto; */
            /* display: block; */
            /* display: flex; */
            
        }

        

        .step .image-container {

            white-space: nowrap;
            text-align: center;
            /* Allow images to shrink but not below their intrinsic size */
            /* flex-shrink: 0; */
            /* width: 500px; */
            display:flex; 
            /* margin: auto; */
            /* display: block; */
            flex-direction: row;
        }

        .step .image-container img {
            
            /* width: 25%; */
            /* height: 100%; */
            /* white-space: nowrap; */
            max-width: 100%;
            /* max-height: 400px; */
            vertical-align: middle;
            /* width: 30%; */
            display: inline-block;
            /* float: right; */
            /* width: 60%; */
            /* margin: auto; */
            /* display: flex; */
            /* padding: 5px; */
        }

        @media (max-width: 750px) {
        /* @media (max-width: 200px) { */
            .centered, .lefty, .lefty-large, .righty, .righty-large, .fully {
                width: 90vw;
                margin: 0 auto;
                /* margin: 50 auto; */
                flex: 33.33%;
            }
            /* .pg-intro {
                color: #fff;
                font-size: 1.3em;
                line-height: 1.35em;
                font-family: "FranklinITCProBold", Helvetica, Arial, sans-serif;
                text-shadow: 1px 1px #000;
            } */
        }

        

        /* Fix issue on mobile browser where scroll breaks  */
        .mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan,
        .mapboxgl-canvas-container.mapboxgl-touch-zoom-rotate.mapboxgl-touch-drag-pan .mapboxgl-canvas {
            touch-action: unset;
        }

        #myTitle{
            /* border: 5px solid; */
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding-top: 1000px;
            padding-bottom: 1000px;
            z-index: 10;
        }

        #p2{
            color: #fff;
            font-size: 3.5em !important;
            text-transform: uppercase;
            margin-bottom: 0px !important;
            text-shadow: 3px 3px #000;
            text-align: center;
            font-family: "PostoniStandardBold",Georgia,serif;
            font-weight: normal;
        }

        #p3{
            text-align: center;
            color: #fff;
            font-size: 1.3em;
            line-height: 1.35em;
            font-family: "FranklinITCProBold", Helvetica, Arial, sans-serif;
            text-shadow: 2px 2px #000;
            font-weight: bolder;
        }

        .infographic{
            /* border: 5px solid; */
            bottom:65rem;
            width:20rem;
            height:20rem;
            margin:50px ;
            float:right;
            background-color: rgb(0,0,0,0);
            position:relative;
        }

        .infoText{
            color: #dddddd;
            text-shadow: 0 0 5px #000000;
            font-size: 18px;
            font-family: sans-serif;
            font-weight: 800;
        }

        .butt-container {
            white-space: nowrap;
            text-align: center;
            /* display:flex;  */
            /* flex-direction: row; */
            flex-flow:row wrap;
        }

        /* CSS */
        .butt-container .butt {
        align-items: center;
        appearance: none;
        background-color: #fff;
        border-radius: 24px;
        border-style: solid;
        box-shadow: rgba(0, 0, 0, .5) 0 3px 5px -1px,rgba(0, 0, 0, .14) 0 6px 10px 0,rgba(0, 0, 0, .12) 0 1px 18px 0;
        box-sizing: border-box;
        color: #3c4043;
        cursor: pointer;
        display: inline-block;
        fill: currentcolor;
        font-family: "Google Sans",Roboto,Arial,sans-serif;
        font-size: 16px;
        font-weight: 700;
        height: 48px;
        justify-content: center;
        letter-spacing: .25px;
        line-height: normal;
        max-width: 100%;
        overflow: visible;
        padding: 2px 24px;
        /* padding-top: 10px;
        padding- */
        position: relative;
        text-align: center;
        text-transform: none;
        transition: box-shadow 280ms cubic-bezier(.4, 0, .2, 1),opacity 15ms linear 30ms,transform 270ms cubic-bezier(0, 0, .2, 1) 0ms;
        user-select: none;
        -webkit-user-select: none;
        touch-action: manipulation;
        width: auto;
        will-change: transform,opacity;
        z-index: 0;
        margin: 10px;
        }

        .butt-container .butt:hover {
        background: #F6F9FE;
        color: #174ea6;
        }

        .butt-container .butt:active {
        box-shadow: 0 4px 4px 0 rgb(60 64 67 / 30%), 0 8px 12px 6px rgb(60 64 67 / 15%);
        outline: none;
        }

        .butt-container .butt:focus {
        outline: none;
        border: 2px solid #4285f4;
        }

        .butt-container .butt:not(:disabled) {
        box-shadow: rgba(60, 64, 67, .3) 0 1px 3px 0, rgba(60, 64, 67, .15) 0 4px 8px 3px;
        }

        .butt-container .butt:not(:disabled):hover {
        box-shadow: rgba(60, 64, 67, .3) 0 2px 3px 0, rgba(60, 64, 67, .15) 0 6px 10px 4px;
        }

        .butt-container .butt:not(:disabled):focus {
        box-shadow: rgba(60, 64, 67, .3) 0 1px 3px 0, rgba(60, 64, 67, .15) 0 4px 8px 3px;
        }

        .butt-container .butt:not(:disabled):active {
        box-shadow: rgba(60, 64, 67, .3) 0 4px 4px 0, rgba(60, 64, 67, .15) 0 8px 12px 6px;
        }

        .butt-container .butt:disabled {
        box-shadow: rgba(60, 64, 67, .3) 0 1px 3px 0, rgba(60, 64, 67, .15) 0 4px 8px 3px;
        }

        /* #butt{
            position: relative;
            color: black;
            background-color: white;
            border-radius: 0.5rem;
            border-width: 2px;
            border-color: #000;
            top: 50%;
            left: 50%;
            height: 3rem;
            width: 6rem;
            transform: translate(-50%, -50%);
            z-index: 15;
        } */

        </style>
</head>
<body>


<!-- CUSTOMIZATIONS:
    can add more than one image by putting them in an array
    can change color along with opacity of map shit
    can change opacity of individual backgrounds for chapters -->
    
<div id="map"></div>
<div id="mapInset"></div>
<div id="story"></div>

<div id="myTitle">
    <p id="p2">Parque Nacional Volcanes del Salar<br /><br />Muy Pronto a Chile</p>
    <!-- <p id="p3">Muy Pronto a Chile</p> -->
    <p id="p3"><br />Coming soon to Chile: Salt Flat Volcanoes National Park</p>
    <p id="p3">Por/By: Spencer Greenfield</p>
</div>

<script src="./config.js"></script>

<script>




var initLoad = true;
var opacityTypes = {
    'fill': ['fill-opacity'],
    'line': ['line-opacity'],
    'circle': ['circle-opacity', 'circle-stroke-opacity'],
    'symbol': ['icon-opacity', 'text-opacity'],
    'raster': ['raster-opacity'],
    'fill-extrusion': ['fill-extrusion-opacity'],
    'heatmap': ['heatmap-opacity']
}

var colorTypes = {
    'fill': ['fill-color'],
    'line': ['line-color'],
    'circle': ['circle-color', 'circle-stroke-color'],
    'symbol': ['icon-color', 'text-color'],
    'raster': ['raster-color'],
    'fill-extrusion': ['fill-extrusion-color'],
    'heatmap': ['heatmap-color']
}

var alignments = {
    'left': 'lefty',
    'left-large':'lefty-large',
    'center': 'centered',
    'right': 'righty',
    'right-large': 'righty-large',
    'full': 'fully'
}

// function setImageSize(divID) {
//     var images = Array.from(document.getElementById(divID).getElementsByTagName("img"));
//     images.forEach(function(img) {
//         img.style.height = 800;
//         // img.style.height = parentContainerHeight - 1000;
//         // img.style.width = (img.offsetWidth * scaleFactor) + "px";
//     });
// }

var scaleCount = 0;

function addScale() {
    if (scaleCount == 0) {
        map.addControl(new mapboxgl.ScaleControl())
        scaleCount = 1
    } 
}

function getLayerOpacityType(layer) {
    var layerType = window.map.getLayer(layer).type;
    return opacityTypes[layerType];
}

function getLayerColorType(layer) {
    var layerType = map.getLayer(layer).type;
    return colorTypes[layerType];
}


function setLayerOpacity(layer) {
    
    var opacityProps = getLayerOpacityType(layer.layer);
    opacityProps.forEach(function(prop) {
        var options = {};
        if (layer.duration) {
            var transitionProp = prop + "-transition";
            options = { "duration": layer.duration };
            map.setPaintProperty(layer.layer, transitionProp, options);
        }
        map.setPaintProperty(layer.layer, prop, layer.opacity, options);
    });
}

function setLayerColor(layer) {
    var colorProps = getLayerColorType(layer.layer);
    colorProps.forEach(function(prop) {
        map.setPaintProperty(layer.layer, prop, layer.color);
    });
}

var story = document.getElementById('story');
var features = document.createElement('div');
features.setAttribute('id', 'features');

var header = document.createElement('div');

if (config.title) {
    var titleText = document.createElement('h1');
    titleText.innerText = config.title;
    header.appendChild(titleText);
}

if (config.subtitle) {
    var subtitleText = document.createElement('h2');
    subtitleText.innerText = config.subtitle;
    header.appendChild(subtitleText);
}

if (config.byline) {
    var bylineText = document.createElement('p');
    bylineText.innerText = config.byline;
    header.appendChild(bylineText);
}

if (header.innerText.length > 0) {
    header.classList.add(config.theme);
    header.setAttribute('id', 'header');
    story.appendChild(header);
}



var prevID
var prevChapter
var prevContainer

config.chapters.forEach((record, idx) => {
    var container = document.createElement('div');
    // if (prevID !== record.id){
        // prevID = record.id

        // var container = document.createElement('div');
        var chapter = document.createElement('div');

        // prevChapter = chapter
        // prevContainer = container

        if (record.title) {
            var title = document.createElement('h3');
            title.innerText = record.title;
            chapter.appendChild(title);
        }

        if (record.embed) {
            var imageContainer = document.createElement("div");
            imageContainer.className = "image-container";
            var embedded = document.createElement('iframe');
            // var image = new ();
            embedded.src = record.embed;
            imageContainer.appendChild(embedded);
            chapter.appendChild(imageContainer);

            window.addEventListener('load', function() {
                    adjustImageSizes();
            });
            window.addEventListener('resize', adjustImageSizes);

            function adjustImageSizes() {
                // ADJUSTED FOR PADDING
                var parentContainerWidth = container.querySelector(".image-container").clientWidth - 100 - 10;
                var parentContainerHeight = container.querySelector(".image-container").clientHeight - 50 - 10;
                
                var images = Array.from(chapter.getElementsByTagName("img"));

                calculateWidths();

                function calculateWidths() {
                    var totalImagesWidth = 0;

                    // Calculate the total width occupied by all images
                    images.forEach(function(img) {
                    totalImagesWidth += img.offsetWidth;
                    });

                    // Calculate the scaling factor
                    var scaleFactor = parentContainerWidth / totalImagesWidth;

                    images.forEach(function(img) {
                        img.style.height = parentContainerHeight - 1000;
                        img.style.width = (img.offsetWidth * scaleFactor) + "px";
                        
                    });
                }
            }
        }
        
        if (record.image) {

            // Accommodating more than one image in a step
            if (Array.isArray(record.image)) {

                var imageContainer = document.createElement("div");
                imageContainer.className = "image-container";

                record.image.forEach(img =>
                {
                    var image = new Image();
                    image.src = img;
                    imageContainer.appendChild(image);

                });

                chapter.appendChild(imageContainer);


                // Adjusting image sizes dynamically based on the number of images in the array for a given step
            }

            else{
                var imageContainer = document.createElement("div");
                imageContainer.className = "image-container";
                var image = new Image();
                image.src = record.image;
                imageContainer.appendChild(image);
                chapter.appendChild(imageContainer);
            }


            

            window.addEventListener('load', function() {
                adjustImageSizes();
                onLoad3D();
            });

            window.addEventListener('resize', adjustImageSizes);

            function adjustImageSizes() {

                // ADJUSTED FOR PADDING
                var parentContainerWidth = container.querySelector(".image-container").clientWidth - 100 - 10;
                var parentContainerHeight = container.querySelector(".image-container").clientHeight - 50 - 10;
                
                var images = Array.from(chapter.getElementsByTagName("img"));

                calculateWidths();

                function calculateWidths() {
                    var totalImagesWidth = 0;

                    // Calculate the total width occupied by all images
                    images.forEach(function(img) {
                    totalImagesWidth += img.offsetWidth;
                    });

                    // Calculate the scaling factor
                    var scaleFactor = parentContainerWidth / totalImagesWidth;

                    images.forEach(function(img) {
                        img.style.height = parentContainerHeight - 1000
                        img.style.width = (img.offsetWidth * scaleFactor) + "px";
                        
                    });
                }
            }

        }

        if (record.description) {
            var story = document.createElement('p');
            story.innerHTML = record.description;
            chapter.appendChild(story);
        }

        container.setAttribute('id', record.id);
        container.classList.add('step');
        if (idx === 0) {
            container.classList.add('active');
        }

        // themeName=config.theme
        chapter.classList.add(config.theme);

        // alert(document.querySelectorAll('#features').length);

        // if(features.childNodes.length > 0) {
        // if(document.querySelectorAll(".".concat(config.theme)).length > 1) {



        // rgbBackgroundColor = getComputedStyle(document.querySelector(".".concat(config.theme))).backgroundColor;
        // rgbBackgroundColor = getComputedStyle(document.querySelectorAll(".".concat(config.theme))[1]).backgroundColor;
        // rgbBackgroundColor = getComputedStyle(chapter.querySelector(".".concat(config.theme))).backgroundColor;

        
        // all of the below is so that we can set opacity and color individually, and it defaults to the theme if we don't set a background color
        if (typeof record.opacity == 'undefined' && record.backgroundColor !== 'undefined') {
            chapter.style["backgroundColor"] = record.backgroundColor;
        }
        else if (typeof record.opacity !== 'undefined'){
            // clipping off the rgb( and the last parentheses for below
            if(typeof record.backgroundColor == 'undefined'){

                // gets background color in (r,g,b) format
                var result,
                el = document.body.appendChild(document.createElement("div")),
                styleProp = 'background-color',
                style;

                el.id = 'features';
                el.classList.add(config.theme)
                style = el.currentStyle || window.getComputedStyle(el, null);
                rgbBackgroundColor = style[styleProp] || "unknown";

                // Remove the element
                document.body.removeChild(el);

                rgbBackgroundColor = rgbBackgroundColor.substring(4, rgbBackgroundColor.length - 1);
                chapter.style["backgroundColor"] = 'rgba('.concat(rgbBackgroundColor,',',String(record.opacity),')');
                
            }
            if (typeof record.backgroundColor !== 'undefined'){
                chapter.style["backgroundColor"] = 'rgba('.concat(record.backgroundColor,',',String(record.opacity),')');
            }
            // else if (typeof record.backgroundColor !== 'undefined'){
            //     chapter.style["backgroundColor"] = 'rgba('.concat(record.backgroundColor,',',String(record.opacity),')');
            // }
        }
        // }

        if (typeof record.textColor !== 'undefined'){
            chapter.style["color"] = record.textColor;
        }

        if (typeof record.textShadow !== 'undefined'){
            chapter.style["text-shadow"] = record.textShadow;
        }

        container.appendChild(chapter);
        container.classList.add(alignments[record.alignment] || 'centered');
        if (record.hidden) {
            container.classList.add('hidden');
        }
        
        features.appendChild(container);
    // }

    // else if (prevID == record.id){

    //     chapter = prevChapter
    //     // container = prevContainer
        
    //     if (record.title) {
    //         var title = document.createElement('h3');
    //         title.innerText = record.title;
    //         chapter.appendChild(title);
    //     }
        
    //     if (record.image) {
    //         if (Array.isArray(record.image)) {
    //             record.image.forEach(img =>
    //             {
    //                 var image = new Image();
    //                 image.src = img;
    //                 chapter.appendChild(image);
    //             });
    //         }
    //         else{
    //             var image = new Image();
    //             image.src = record.image;
    //             chapter.appendChild(image);
    //         }
    //     }

    //     if (record.description) {
    //         var story = document.createElement('p');
    //         story.innerHTML = record.description;
    //         chapter.appendChild(story);
    //     }

    //     container.setAttribute('id', record.id);
    //     container.classList.add('step');
    //     if (idx === 0) {
    //         container.classList.add('active');
    //     }

    //     chapter.classList.add(config.theme);
    //     // container.appendChild(chapter);
    //     container.classList.add(alignments[record.alignment] || 'centered');
    //     if (record.hidden) {
    //         container.classList.add('hidden');
    //     }
    //     container.style.display = 'left';
    //     features.appendChild(container);
    // }

});

story.appendChild(features);


var footer = document.createElement('div');

if (config.footer) {
    var footerText = document.createElement('p');
    footerText.innerHTML = config.footer;
    footer.appendChild(footerText);
}

if (footer.innerText.length > 0) {
    footer.classList.add(config.theme);
    footer.setAttribute('id', 'footer');
    story.appendChild(footer);
}

mapboxgl.accessToken = config.accessToken;

const transformRequest = (url) => {
    const hasQuery = url.indexOf("?") !== -1;
    const suffix = hasQuery ? "&pluginName=scrollytellingV2" : "?pluginName=scrollytellingV2";
    return {
      url: url + suffix
    }
}

var map = new mapboxgl.Map({
    container: 'map',
    style: config.style,
    center: config.chapters[0].location.center,
    zoom: config.chapters[0].location.zoom,
    bearing: config.chapters[0].location.bearing,
    pitch: config.chapters[0].location.pitch,
    interactive: false,
    transformRequest: transformRequest,
    projection: config.projection
});


// const onClickOutside = (element, callback) => {
//   document.addEventListener('click', e => {
//     if (!element.contains(e.target)) callback();
//   });
// };

// function hello() {
//     console.log('Hello!');
// }

var count = 0;
let start;
let animationID;
const cancelAnimationFrame = window.cancelAnimationFrame || window.mozCancelAnimationFrame;

function createButton() {
    
    // element = document.getElementsByClassName('butt'); 
    // if ($(".mydivclass")[0])
    if (count == 0) {
        var main = document.getElementById('stepTwo');
        var buttContainer = document.createElement("div");
        buttContainer.className = "butt-container";
        var newButton1 = document.createElement('button');
        newButton1.id = 'but1';
        newButton1.classList.add("butt");
        newButton1.textContent = 'A';
        window.addEventListener('click', function(e){   
            if (document.getElementById('but1').contains(e.target)){
                // Clicked in box
                map.flyTo({
                    center: [-68.21183, -23.54017],
                    zoom: 8.67,
                    bearing: 7.01,
                    pitch: 28.01
                    // essential: true // this animation is considered essential with respect to prefers-reduced-motion
                });
                window.cancelAnimationFrame(animationID);
                if(document.getElementById('box1') == null) {
                    var textExplain = document.createElement('div');
                    textExplain.classList.add("infographic");
                    textExplain.id = ("box1")
                    var geo1 = document.createElement('p');
                    geo1.classList.add("infoText");
                    var text = document.createTextNode("The Salar itself is actually far older than the active margin on which it lies. Its white color comes from water from the Pacific Ocean when volcanic eruptions occurred near the Chilean coast 200 million years ago. Scroll up to the diagram to see if you can identify the features.");
                    geo1.appendChild(text);
                    textExplain.appendChild(geo1);
                    document.body.appendChild(textExplain);
                }   
            } else{
                // console.log('hello!!!');
                if(document.getElementById("box1")){
                    document.getElementById("box1").remove();
                }
            }
        });
        buttContainer.appendChild(newButton1);
        // main.appendChild(newButton1);
        var newButton2 = document.createElement('button');
        newButton2.id = 'but2';
        newButton2.classList.add("butt");
        newButton2.textContent = 'B';
        window.addEventListener('click', function(e){   
            if (document.getElementById('but2').contains(e.target)){
                // Clicked in box
                map.flyTo({
                    // center: [-68.34583, -23.08766],
                    center: [-68.35851, -23.1],
                    zoom: 12,
                    bearing: -60,
                    pitch: 70
                    // essential: true // this animation is considered essential with respect to prefers-reduced-motion
                });
                window.cancelAnimationFrame(animationID);
                if(document.getElementById('box2') == null) {
                    var textExplain = document.createElement('div');
                    textExplain.classList.add("infographic");
                    textExplain.id = ("box2")
                    var geo1 = document.createElement('p');
                    geo1.classList.add("infoText");
                    var text = document.createTextNode("At front: A fault scarp reveals the stratification of the rock underneath the ground. This is also a good example of a scarp's vulnerability to erosion.");
                    geo1.appendChild(text);
                    textExplain.appendChild(geo1);
                    document.body.appendChild(textExplain);
                }   
            } else{
                // console.log('hello!!!');
                if(document.getElementById("box2")){
                    document.getElementById("box2").remove();
                }
            }
        });
        buttContainer.appendChild(newButton2);
        var newButton3 = document.createElement('button');
        newButton3.id = 'but3';
        newButton3.classList.add("butt");
        newButton3.textContent = 'C';
        window.addEventListener('click', function(e){   
            if (document.getElementById('but3').contains(e.target)){
                // Clicked in box
                map.flyTo({
                    center: [-68.45252, -23.33659],
                    zoom: 11,
                    bearing: -60,
                    pitch: 50
                });
                window.cancelAnimationFrame(animationID);
                if(document.getElementById('box3') == null) {
                    var textExplain = document.createElement('div');
                    textExplain.classList.add("infographic");
                    textExplain.id = ("box3")
                    var geo1 = document.createElement('p');
                    geo1.classList.add("infoText");
                    var text = document.createTextNode("Alternating anticline (convex) and syncline (concave) folds were created by ancient margins.");
                    geo1.appendChild(text);
                    textExplain.appendChild(geo1);
                    document.body.appendChild(textExplain);
                }   
            } else{
                // console.log('hello!!!');
                map.setPaintProperty('foredune','fill-opacity',0);
                // map.setPaintProperty('foredune','fill-color','purple');
                if(document.getElementById("box3")){
                    document.getElementById("box3").remove();
                }
            }
        });
        buttContainer.appendChild(newButton3);
        var newButton4 = document.createElement('button');
        newButton4.id = 'but4';
        newButton4.classList.add("butt");
        newButton4.textContent = 'D';
        window.addEventListener('click', function(e){   
            if (document.getElementById('but4').contains(e.target)){
                // Clicked in box
                map.flyTo({
                    center: [-67.83152, -23.50857],
                    zoom: 10,
                    bearing: 30,
                    pitch: 60
                    // essential: true // this animation is considered essential with respect to prefers-reduced-motion
                });
                window.cancelAnimationFrame(animationID);
                if(document.getElementById('box4') == null) {
                    var textExplain = document.createElement('div');
                    textExplain.classList.add("infographic");
                    textExplain.id = ("box4")
                    var geo1 = document.createElement('p');
                    geo1.classList.add("infoText");
                    var text = document.createTextNode("Active volcanoes east of the salt flat form represent the volcanic arc of the subduction zone, making them a part of the primary Andes mountain range.");
                    geo1.appendChild(text);
                    textExplain.appendChild(geo1);
                    document.body.appendChild(textExplain);
                }   
            } else{
                // console.log('hello!!!');
                if(document.getElementById("box4")){
                    document.getElementById("box4").remove();
                }
            }
        });
        buttContainer.appendChild(newButton4);
        main.appendChild(buttContainer);
        // var newButton5 = document.createElement('button');
        // newButton5.id = 'but5';
        // newButton5.classList.add("butt");
        // newButton5.textContent = 'Click me!';
        // main.appendChild(newButton5);
        count = 1
    }

}

function setLow(){
    document.getElementById("stepOne").style.paddingTop='1000px';
}


// 40.76604844674632, -72.75969916769675

function flyToEnd() {

    // var targetRoute = [
    //     [-67.9099820290795,-22.787314616758735], 
    //     [-67.85738, -22.88106],
    //     [-67.77309, -22.93844],
    //     [-67.75209, -23.09560],
    //     [-67.71823, -23.29026],
    //     [-67.62790, -23.65551],
    //     [-67.63508, -23.87402],
    //     [-67.95362, -23.93779],
    //     [-68.23678, -23.86765],
    //     [-68.56863, -23.90264],
    //     [-68.80108, -23.68401],
    //     [-68.74269, -23.34978],
    //     [-68.50624, -23.10581],
    //     [-68.25423, -23.01443] 
    // ];

    // var cameraRoute = targetRoute;

    // map.addSource('trace', {
    //     type: 'geojson',
    //     data: {
    //         'type': 'Feature',
    //         'properties': {},
    //         'geometry': {
    //             'type': 'LineString',
    //             'coordinates': targetRoute
    //         }
    //     }
    // });

    // const animationDuration = 32000;
    // const cameraAltitude = 15000;
    // // get the overall distance of each route so we can interpolate along them
    // const routeDistance = turf.lineDistance(turf.lineString(targetRoute));
    // const cameraRouteDistance = turf.lineDistance(
    //     turf.lineString(cameraRoute)
    // );

    function rotateCamera(timestamp){
        map.rotateTo((timestamp / 100) % 360, { duration: 0 });
        // Request the next frame of the animation.
        animationID = requestAnimationFrame(rotateCamera);
    }

    animationID = requestAnimationFrame(rotateCamera);

    // function frame(time) {
    //     if (!start) start = time;
    //     // phase determines how far through the animation we are
    //     const phase = (time - start) / animationDuration;

    //     // phase is normalized between 0 and 1
    //     // when the animation is finished, reset start to loop the animation
    //     if (phase > 1) {
    //         // wait 1.5 seconds before looping
    //         setTimeout(() => {
    //             start = 0.0;
    //         }, 1500);
    //     }

    //     // use the phase to get a point that is the appropriate distance along the route
    //     // this approach syncs the camera and route positions ensuring they move
    //     // at roughly equal rates even if they don't contain the same number of points
    //     const alongRoute = turf.along(
    //         turf.lineString(targetRoute),
    //         routeDistance * phase
    //     ).geometry.coordinates;

    //     const alongCamera = turf.along(
    //         turf.lineString(cameraRoute),
    //         cameraRouteDistance * phase
    //     ).geometry.coordinates;

    //     const camera = map.getFreeCameraOptions();

    //     // set the position and altitude of the camera
    //     camera.position = mapboxgl.MercatorCoordinate.fromLngLat(
    //         {
    //             lng: alongCamera[0],
    //             lat: alongCamera[1]
    //         },
    //         cameraAltitude
    //     );

    //     // tell the camera to look at a point along the route
    //     camera.lookAtPoint({
    //         lng: alongRoute[0],
    //         lat: alongRoute[1]
    //     });

    //     map.setFreeCameraOptions(camera);

    

    //     animationID = window.requestAnimationFrame(frame);
    // }

    // animationID = window.requestAnimationFrame(frame);
};

// Create a inset map if enabled in config.js
if (config.inset) {
 var insetMap = new mapboxgl.Map({
    container: 'mapInset', // container id
    style: 'mapbox://styles/mapbox/dark-v10', //hosted style id
    center: config.chapters[0].location.center,
    // Hardcode above center value if you want insetMap to be static.
    zoom: 3, // starting zoom
    hash: false,
    interactive: false,
    attributionControl: false,
    //Future: Once official mapbox-gl-js has globe view enabled,
    //insetmap can be a globe with the following parameter.
    //projection: 'globe'
  });
}

if (config.showMarkers) {
    var marker = new mapboxgl.Marker({ color: config.markerColor });
    marker.setLngLat(config.chapters[0].location.center).addTo(map);
}

// instantiate the scrollama
var scroller = scrollama();


map.on("load", function() {
    if (config.use3dTerrain) {
        map.addSource('mapbox-dem', {
            'type': 'raster-dem',
            'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
            'tileSize': 512,
            'maxzoom': 14
        });
        // add the DEM source as a terrain layer with exaggerated height
        map.setTerrain({'source': 'mapbox-dem', 'exaggeration': 3 });

        // add a sky layer that will show when the map is highly pitched
        map.addLayer({
            'id': 'sky',
            'type': 'sky',
            'paint': {
                'sky-type': 'atmosphere',
                'sky-atmosphere-sun': [0.0, 0.0],
                'sky-atmosphere-sun-intensity': 15
            }
        });
        
        map.addControl(new mapboxgl.ScaleControl());

    };

    // As the map moves, grab and update bounds in inset map.
    if (config.inset) {
    map.on('move', getInsetBounds);
    }
    // setup the instance, pass callback functions
    scroller
    .setup({
        step: '.step',
        offset: 0.5,
        progress: true
    })
    .onStepEnter(async response => {
        var current_chapter = config.chapters.findIndex(chap => chap.id === response.element.id);
        var chapter = config.chapters[current_chapter];
        
        response.element.classList.add('active');
        map[chapter.mapAnimation || 'flyTo'](chapter.location);

        // Incase you do not want to have a dynamic inset map,
        // rather want to keep it a static view but still change the
        // bbox as main map move: comment out the below if section.
        if (config.inset) {
          if (chapter.location.zoom < 5) {
            insetMap.flyTo({center: chapter.location.center, zoom: 0});
          }
          else {
            insetMap.flyTo({center: chapter.location.center, zoom: 3});
          }
        }
        if (config.showMarkers) {
            marker.setLngLat(chapter.location.center);
        }

        if (chapter.onChapterEnter.length > 0) {
            chapter.onChapterEnter.forEach(element => 
                {
                    if (typeof element.color !== 'undefined') {setLayerColor(element)};
                    if (typeof element.opacity !== 'undefined') {setLayerOpacity(element)};
                }
            )
        }

        if (chapter.callback) {
            if (Array.isArray(chapter.callback)) {
                {
                    chapter.callback.forEach (element => window[element]()) ;
                }
            }
            else{
                window[chapter.callback]();
            }
        }

        if (chapter.rotateAnimation) {
            map.once('moveend', () => {
                const rotateNumber = map.getBearing();
                map.rotateTo(rotateNumber + 180, {
                    duration: 30000, easing: function (t) {
                        return t;
                    }
                });
            });
        }
        if (config.auto) {
             var next_chapter = (current_chapter + 1) % config.chapters.length;
             map.once('moveend', () => {
                 document.querySelectorAll('[data-scrollama-index="' + next_chapter.toString() + '"]')[0].scrollIntoView();
             });
        }
    })
    .onStepExit(response => {
        
        var chapter = config.chapters.find(chap => chap.id === response.element.id);
        response.element.classList.remove('active');

        if (chapter.onChapterExit.length > 0) {
            chapter.onChapterExit.forEach(element => 
                {
                    if (typeof element.color !== 'undefined') {setLayerColor(element)};
                    if (typeof element.opacity !== 'undefined') {setLayerOpacity(element)};
                }
            )
        }

    });

    if (config.auto) {
        document.querySelectorAll('[data-scrollama-index="0"]')[0].scrollIntoView();
    }
});

//Helper functions for insetmap
function getInsetBounds() {
            let bounds = map.getBounds();

            let boundsJson = {
                "type": "FeatureCollection",
                "features": [{
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": [
                            [
                                [
                                    bounds._sw.lng,
                                    bounds._sw.lat
                                ],
                                [
                                    bounds._ne.lng,
                                    bounds._sw.lat
                                ],
                                [
                                    bounds._ne.lng,
                                    bounds._ne.lat
                                ],
                                [
                                    bounds._sw.lng,
                                    bounds._ne.lat
                                ],
                                [
                                    bounds._sw.lng,
                                    bounds._sw.lat
                                ]
                            ]
                        ]
                    }
                }]
            }

            if (initLoad) {
                addInsetLayer(boundsJson);
                initLoad = false;
            } else {
                updateInsetLayer(boundsJson);
            }

        }

function addInsetLayer(bounds) {
    insetMap.addSource('boundsSource', {
        'type': 'geojson',
        'data': bounds
    });

    insetMap.addLayer({
        'id': 'boundsLayer',
        'type': 'fill',
        'source': 'boundsSource', // reference the data source
        'layout': {},
        'paint': {
            'fill-color': '#fff', // blue color fill
            'fill-opacity': 0.2
        }
    });
    // // Add a black outline around the polygon.
    insetMap.addLayer({
        'id': 'outlineLayer',
        'type': 'line',
        'source': 'boundsSource',
        'layout': {},
        'paint': {
            'line-color': '#000',
            'line-width': 1
        }
    });
}

function updateInsetLayer(bounds) {
    insetMap.getSource('boundsSource').setData(bounds);
}



// setup resize event
window.addEventListener('resize', scroller.resize);



// var tit = document.createElement('div');
// tit.setAttribute('id','myTitle');
// // var titText = document.createElement('h1');
// var titText = document.createTextNode("This is new.");

// titText.innerText = 'texting';
// tit.appendChild(titText);

</script>

</body>
</html>
